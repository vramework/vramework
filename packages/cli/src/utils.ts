import { version } from '../../../package.json'
import { relative, dirname } from 'path'
import { PathToNameAndType, VisitState } from './inspector/visit.js'
import { mkdir, writeFile } from 'fs/promises'

export const getFileImportRelativePath = (
  from: string,
  to: string,
  packageMappings: Record<string, string>
): string => {
  let filePath = relative(dirname(from), to)
  if (!/^\.+\//.test(filePath)) {
    filePath = `./${filePath}`
  }
  for (const [path, packageName] of Object.entries(packageMappings)) {
    if (to.includes(path)) {
      filePath = filePath.replace(new RegExp(`.*${path}`), packageName)
      break
    }
  }
  return filePath.replace('.ts', '')
}

interface Meta {
  file: string
  variable: string
  type: string
  typePath: string
}

export type FilesAndMethods = {
  vrameworkConfig: Meta
  userSessionType: Meta
  sessionServicesType: Meta
  singletonServicesFactory: Meta
  sessionServicesFactory: Meta
}

export interface VrameworkCLIOptions {
  config?: string
  configFileType?: string
  userSessionType?: string
  singletonServicesFactoryType?: string
  sessionServicesFactoryType?: string
}

const getMetaTypes = (
  type: string,
  errors: Map<string, PathToNameAndType>,
  map: PathToNameAndType,
  desiredType?: string
) => {
  if (desiredType) {
    const entries = Object.entries(map)
    for (const [file, meta] of entries) {
      for (const { type, variable, typePath } of meta) {
        if (type === desiredType) {
          return { file, variable, type, typePath }
        }
      }
    }
    errors.set(`No ${desiredType} found that extends ${type}`, map)
    return undefined
  }

  const totalValues = Object.values(map).flat()
  if (totalValues.length === 0) {
    errors.set(`No ${type} found`, map)
  } else if (totalValues.length > 1) {
    errors.set(`More than one ${type} found`, map)
  } else {
    const [file, [{ type, variable, typePath }]] = Object.entries(map)[0]
    return { file, type, variable, typePath }
  }

  return undefined
}

export const getVrameworkFilesAndMethods = async (
  {
    vrameworkConfigs,
    sessionServicesTypeImportMap: httpSessionServicesTypeImportMap,
    userSessionTypeImportMap,
    sessionServicesFactories,
    singletonServicesFactories,
  }: VisitState,
  packageMappings: Record<string, string>,
  outputFile: string,
  {
    configFileType,
    singletonServicesFactoryType,
    sessionServicesFactoryType,
  }: VrameworkCLIOptions
): Promise<FilesAndMethods> => {
  let errors = new Map<string, PathToNameAndType>()

  const result: Partial<FilesAndMethods> = {
    vrameworkConfig: getMetaTypes(
      'CoreConfig',
      errors,
      vrameworkConfigs,
      configFileType
    ),
    userSessionType: getMetaTypes(
      'CoreUserSession',
      errors,
      userSessionTypeImportMap,
      configFileType
    ),
    sessionServicesType: getMetaTypes(
      'CoreServices',
      errors,
      httpSessionServicesTypeImportMap
    ),
    singletonServicesFactory: getMetaTypes(
      'CreateSingletonServices',
      errors,
      singletonServicesFactories,
      singletonServicesFactoryType
    ),
    sessionServicesFactory: getMetaTypes(
      'CreateSessionServices',
      errors,
      sessionServicesFactories,
      sessionServicesFactoryType
    ),
  }

  if (errors.size > 0) {
    const result: string[] = ['Found errors:']
    errors.forEach((filesAndMethods, message) => {
      result.push(`- ${message}`)
      for (const [file, methods] of Object.entries(filesAndMethods)) {
        result.push(
          `\t* file: ${getFileImportRelativePath(outputFile, file, packageMappings)}`
        )
        result.push(
          `\t* methods: ${methods.map(({ variable, type }) => `${variable}: ${type}`).join(', ')}`
        )
      }
    })

    console.error(result.join('\n'))
    process.exit(1)
  }

  return result as FilesAndMethods
}

export const writeFileInDir = async (
  path: string,
  content: string,
  ignoreModifyComment: boolean = false
) => {
  if (content.includes('server-only')) {
    content = content.replace(
      "'server-only'",
      `'server-only'\n\n${ignoreModifyComment ? '' : DO_NOT_MODIFY_COMMENT}`
    )
  } else {
    content = `${ignoreModifyComment ? '' : DO_NOT_MODIFY_COMMENT}${content}`
  }

  await mkdir(dirname(path), { recursive: true })
  await writeFile(path, content, 'utf-8')
}

export const logCommandInfoAndTime = async <ReturnType = void>(
  commandStart: string,
  commandEnd: string,
  callback: (...args: any[]) => Promise<ReturnType>
) => {
  const start = Date.now()
  console.log(`\x1b[34m• ${commandStart}...\x1b[0m`)
  const result = await callback()
  console.log(`\x1b[32m✓ ${commandEnd} in ${Date.now() - start}ms.\x1b[0m`)
  return result
}

export const logVrameworkLogo = () => {
  console.log(`\x1b[33m⚙️ VRAMEWORK CLI ⚙️\n-------------------\x1b[0m`)
}

export const DO_NOT_MODIFY_COMMENT = `/**
* This file was generated by @vramework/cli@${version}
*/\n\n`
